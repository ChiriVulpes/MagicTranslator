import Collectors from "util/Collectors";

declare global {
	type IterableOf<T> = T[] | IterableIterator<T>;

	type SplitIterablesOf<T, K extends string> = {
		[key in K]: IterableIterator<T>;
	} & { [IterableIterator.ALL]: IterableIterator<T> };

	type GeneratorOf<T> = () => IterableOf<T>;

	type GeneratorOrT<T> = T | (() => T);

	type ArrayOfTOrIterablesOfT<T> = Array<T | IterableOf<T>>;

	type Falsey = 0 | "" | null | undefined;

	interface IterableIterator<T> {

		/**
		 * Returns an iterable of type X, using the given map function
		 * @param mapper A function that maps an entry of type T to its corresponding type X
		 */
		map<X> (mapper: (val: T, index: number) => X): IterableIterator<X>;

		/**
		 * Returns an iterable that will loop only over the entries that match the given filter
		 * @param filter A function that returns a truthy value if the entry should be included and a falsey value if it shouldn't
		 */
		filter2<X = T> (filter: (val: T) => any): IterableIterator<X>;

		/**
		 * Returns an iterable that will loop only over the entries that match the given filter
		 * @param filter A function that returns a truthy value if the entry should be included and a falsey value if it shouldn't
		 */
		filter<X = never> (filter: (val: T) => any): IterableIterator<Exclude<T, X>>;

		/**
		 * Returns an iterable that will first loop over the entries in itself, then the entries given
		 * @param items The other items to loop over
		 */
		include<X = T> (...items: Array<IterableOf<X>>): IterableIterator<T | X>;

		/**
		 * Returns a value of type X, generated by iterating through the iterable and calling the reducer function for each.
		 * @param reducer A function that returns a new result, taking a new entry and the result from the previous iteration, or
		 * @param initialValue if it's the first iteration.
		 */
		reduce<X> (reducer: (newValue: T, oldValue?: X) => X, initialValue?: T): X;

		/**
		 * Returns a value of type X, generated with the given collector function.
		 * @param collector A function that takes the iterable, and returns type X
		 * @see `utilities/Collectors` for premade collectors
		 */
		collect<X> (collector: (val: IterableIterator<T>) => X): X;
		/**
		 * Returns an iterable of type X, generated with the given collector function.
		 * @param collector A function that takes the iterable, and returns type X
		 * @see `utilities/Collectors` for premade collectors
		 */
		collect<X> (collector: (val: IterableIterator<T>) => X, iterable: true): IterableIterator<X>;

		/**
		 * Loops the values of this iterable and calls the given function with each value.
		 * @param user A function that takes a value. If the function returns `false`, iteration will not continue.
		 */
		forEach (user: (val: T, index: number) => any, continueGenerate?: false): void;
		/**
		 * Loops the values of this iterable and calls the given function with each value.
		 * @param user A function that takes a value. If the function returns `false`, iteration will not continue.
		 */
		forEach (user: (val: T, index: number) => any, continueGenerate: true): IterableIterator<T>;

		/**
		 * Loops through the values of this iterable until the predicate returns `true` for an entry.
		 * @param predicate A function that will return `true` or `false` for an entry in this iterable.
		 * @returns Whether the predicate ever returned `true`.
		 */
		any (predicate: (val: T, index: number) => boolean): boolean;

		/**
		 * Loops through the values of this iterable until the predicate returns `false` for an entry.
		 * @param predicate A function that will return `true` or `false` for an entry in this iterable.
		 * @returns Whether the predicate ever returned `false`.
		 */
		nevery (predicate: (val: T, index: number) => boolean): boolean;

		/**
		 * Loops through the values of this iterable until the predicate returns `false` for an entry.
		 * @param predicate A function that will return `true` or `false` for an entry in this iterable.
		 * @returns Whether the predicate always returned `true`.
		 */
		every (predicate: (val: T, index: number) => boolean): boolean;

		/**
		 * Loops through the values of this iterable until the predicate returns `true` for an entry.
		 * @param predicate A function that will return `true` or `false` for an entry in this iterable.
		 * @returns Whether the predicate always returned `false`.
		 */
		none (predicate: (val: T, index: number) => boolean): boolean;

		/**
		 * Returns the first value in this iterator, or undefined if there are no values.
		 */
		first (): T | undefined;
		/**
		 * Returns the first value in this iterator.
		 * @param orElse Returns this if there are no values.
		 */
		first (orElse?: T): T;
		/**
		 * Runs the callback on the first value in this iterator.
		 */
		first (user: (val: T) => any): void;

		/**
		 * Returns the last value in this iterator, or undefined if there are no values.
		 *
		 * Note: Will loop through every entry in this iterator.
		 */
		last (): T | undefined;
		/**
		 * Returns the last value in this iterator.
		 * @param orElse Returns this if there are no values.
		 *
		 * Note: Will loop through every entry in this iterator.
		 */
		last (orElse?: T): T;
		/**
		 * Runs the callback on the last value in this iterator.
		 *
		 * Note: Will loop through every entry in this iterator.
		 */
		last (user: (val: T) => any): void;

		/**
		 * Returns a random value in this iterator, or undefined if there are no values.
		 *
		 * Note: Will loop through every entry in this iterator.
		 */
		random (): T | undefined;
		/**
		 * Returns a random value in this iterator.
		 * @param orElse Returns this if there are no values.
		 *
		 * Note: Will loop through every entry in this iterator.
		 */
		random (orElse?: T): T;

		/**
		 * Returns an object of iterators mapped by a splitter function.
		 * @param splitter Takes a value from the iterator and returns which resulting iterator it should be part of.
		 */
		split<K extends string> (splitter: (val: T) => K): SplitIterablesOf<T, K>;

		// tslint:disable max-line-length
		/**
		 * Returns an iterator where any lower level iterables are splatted into the top layer
		 * @param levels The number of levels down the splatting should occur
		 *
		 * Examples:
		 * ```ts
		 * IterableIterator<number>.flat(): IterableIterator<number>
		 * IterableIterator<number | number[]>.flat(): IterableIterator<number>
		 * IterableIterator<number | number[] | number[][]>.flat(): IterableIterator<number>
		 * ```
		 *
		 * Note: If the item you're iterating over is a tuple, you'll need to use the `levels` parameter and provide a type argument,
		 * otherwise it will think it's returning a non-iterable type like `number | boolean` instead of `[number, boolean]`. Example:
		 * ```ts
		 * IterableIterator<number | number[] | number[][]>.flat<number | number[]>(1): IterableIterator<number | number[]>
		 * ```
		 *
		 * Note 2: This method supports any number of layers of iterables, but the smart typing only supports up to 4 layers. Example:
		 * ```ts
		 * IterableIterator<number[][][][]>.flat(): IterableIterator<number>
		 * IterableIterator<number[][][][][]>.flat(): IterableIterator<never>
		 * ```
		 *
		 * Note 3: The smart types for this method were generated using: https://gist.github.com/Yuudaari/9502cf8df426382730f52dd06a2bd243
		 */
		flat<A = undefined> (levels?: number): Extract<A, A> extends infer _ ? (_ extends undefined ? IterableIterator<Extract<T, IterableOf<any>> extends IterableOf<infer B> ? (Exclude<T, IterableOf<any>> extends never ?
			(Extract<B, IterableOf<any>> extends IterableOf<infer C> ? (Exclude<B, IterableOf<any>> extends never ?
				(Extract<C, IterableOf<any>> extends IterableOf<infer D> ? (Exclude<C, IterableOf<any>> extends never ?
					(Extract<D, IterableOf<any>> extends IterableOf<infer E> ? (Exclude<D, IterableOf<any>> extends never ?
						(Extract<E, IterableOf<any>> extends IterableOf<infer F> ? (Exclude<E, IterableOf<any>> extends never ? never : Exclude<E, IterableOf<any>>) : never) |
						(Extract<E, IterableOf<any>> extends IterableOf<infer G> ? (Exclude<E, IterableOf<any>> extends never ? never : Extract<E, IterableOf<any>> extends never ? never :
							(Extract<Extract<E, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer H> ? (Exclude<Extract<E, IterableOf<any>>, IterableOf<any>> extends never ? never : Exclude<Extract<E, IterableOf<any>>, IterableOf<any>>) : never)) : never) : Exclude<D, IterableOf<any>> |
						(Extract<D, IterableOf<any>> extends IterableOf<infer I> ? (Exclude<D, IterableOf<any>> extends never ? never : Extract<D, IterableOf<any>> extends never ? never :
							(Extract<Extract<D, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer J> ? (Exclude<Extract<D, IterableOf<any>>, IterableOf<any>> extends never ? never : Exclude<Extract<D, IterableOf<any>>, IterableOf<any>>) : never)) : never)) : never) |
					(Extract<D, IterableOf<any>> extends IterableOf<infer K> ? (Exclude<D, IterableOf<any>> extends never ? never : Extract<D, IterableOf<any>> extends never ? never :
						(Extract<Extract<D, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer L> ? (Exclude<Extract<D, IterableOf<any>>, IterableOf<any>> extends never ?
							(Extract<L, IterableOf<any>> extends IterableOf<infer M> ? (Exclude<L, IterableOf<any>> extends never ? never : Exclude<L, IterableOf<any>>) : never) |
							(Extract<L, IterableOf<any>> extends IterableOf<infer N> ? (Exclude<L, IterableOf<any>> extends never ? never : Extract<L, IterableOf<any>> extends never ? never :
								(Extract<Extract<L, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer O> ? (Exclude<Extract<L, IterableOf<any>>, IterableOf<any>> extends never ? never : Exclude<Extract<L, IterableOf<any>>, IterableOf<any>>) : never)) : never) : Exclude<Extract<D, IterableOf<any>>, IterableOf<any>> |
							(Extract<Extract<D, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer P> ? (Exclude<Extract<D, IterableOf<any>>, IterableOf<any>> extends never ? never : Extract<Extract<D, IterableOf<any>>, IterableOf<any>> extends never ? never :
								(Extract<Extract<Extract<D, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer Q> ? (Exclude<Extract<Extract<D, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends never ? never : Exclude<Extract<Extract<D, IterableOf<any>>, IterableOf<any>>, IterableOf<any>>) : never)) : never)) : never)) : never) : Exclude<C, IterableOf<any>> |
					(Extract<C, IterableOf<any>> extends IterableOf<infer R> ? (Exclude<C, IterableOf<any>> extends never ? never : Extract<C, IterableOf<any>> extends never ? never :
						(Extract<Extract<C, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer S> ? (Exclude<Extract<C, IterableOf<any>>, IterableOf<any>> extends never ?
							(Extract<S, IterableOf<any>> extends IterableOf<infer U> ? (Exclude<S, IterableOf<any>> extends never ? never : Exclude<S, IterableOf<any>>) : never) |
							(Extract<S, IterableOf<any>> extends IterableOf<infer V> ? (Exclude<S, IterableOf<any>> extends never ? never : Extract<S, IterableOf<any>> extends never ? never :
								(Extract<Extract<S, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer W> ? (Exclude<Extract<S, IterableOf<any>>, IterableOf<any>> extends never ? never : Exclude<Extract<S, IterableOf<any>>, IterableOf<any>>) : never)) : never) : Exclude<Extract<C, IterableOf<any>>, IterableOf<any>> |
							(Extract<Extract<C, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer X> ? (Exclude<Extract<C, IterableOf<any>>, IterableOf<any>> extends never ? never : Extract<Extract<C, IterableOf<any>>, IterableOf<any>> extends never ? never :
								(Extract<Extract<Extract<C, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer Y> ? (Exclude<Extract<Extract<C, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends never ? never : Exclude<Extract<Extract<C, IterableOf<any>>, IterableOf<any>>, IterableOf<any>>) : never)) : never)) : never)) : never)) : never) |
				(Extract<C, IterableOf<any>> extends IterableOf<infer Z> ? (Exclude<C, IterableOf<any>> extends never ? never : Extract<C, IterableOf<any>> extends never ? never :
					(Extract<Extract<C, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer a> ? (Exclude<Extract<C, IterableOf<any>>, IterableOf<any>> extends never ?
						(Extract<a, IterableOf<any>> extends IterableOf<infer b> ? (Exclude<a, IterableOf<any>> extends never ?
							(Extract<b, IterableOf<any>> extends IterableOf<infer c> ? (Exclude<b, IterableOf<any>> extends never ? never : Exclude<b, IterableOf<any>>) : never) |
							(Extract<b, IterableOf<any>> extends IterableOf<infer d> ? (Exclude<b, IterableOf<any>> extends never ? never : Extract<b, IterableOf<any>> extends never ? never :
								(Extract<Extract<b, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer e> ? (Exclude<Extract<b, IterableOf<any>>, IterableOf<any>> extends never ? never : Exclude<Extract<b, IterableOf<any>>, IterableOf<any>>) : never)) : never) : Exclude<a, IterableOf<any>> |
							(Extract<a, IterableOf<any>> extends IterableOf<infer f> ? (Exclude<a, IterableOf<any>> extends never ? never : Extract<a, IterableOf<any>> extends never ? never :
								(Extract<Extract<a, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer g> ? (Exclude<Extract<a, IterableOf<any>>, IterableOf<any>> extends never ? never : Exclude<Extract<a, IterableOf<any>>, IterableOf<any>>) : never)) : never)) : never) |
						(Extract<a, IterableOf<any>> extends IterableOf<infer h> ? (Exclude<a, IterableOf<any>> extends never ? never : Extract<a, IterableOf<any>> extends never ? never :
							(Extract<Extract<a, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer i> ? (Exclude<Extract<a, IterableOf<any>>, IterableOf<any>> extends never ?
								(Extract<i, IterableOf<any>> extends IterableOf<infer j> ? (Exclude<i, IterableOf<any>> extends never ? never : Exclude<i, IterableOf<any>>) : never) |
								(Extract<i, IterableOf<any>> extends IterableOf<infer k> ? (Exclude<i, IterableOf<any>> extends never ? never : Extract<i, IterableOf<any>> extends never ? never :
									(Extract<Extract<i, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer l> ? (Exclude<Extract<i, IterableOf<any>>, IterableOf<any>> extends never ? never : Exclude<Extract<i, IterableOf<any>>, IterableOf<any>>) : never)) : never) : Exclude<Extract<a, IterableOf<any>>, IterableOf<any>> |
								(Extract<Extract<a, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer m> ? (Exclude<Extract<a, IterableOf<any>>, IterableOf<any>> extends never ? never : Extract<Extract<a, IterableOf<any>>, IterableOf<any>> extends never ? never :
									(Extract<Extract<Extract<a, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer n> ? (Exclude<Extract<Extract<a, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends never ? never : Exclude<Extract<Extract<a, IterableOf<any>>, IterableOf<any>>, IterableOf<any>>) : never)) : never)) : never)) : never) : Exclude<Extract<C, IterableOf<any>>, IterableOf<any>> |
						(Extract<Extract<C, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer o> ? (Exclude<Extract<C, IterableOf<any>>, IterableOf<any>> extends never ? never : Extract<Extract<C, IterableOf<any>>, IterableOf<any>> extends never ? never :
							(Extract<Extract<Extract<C, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer p> ? (Exclude<Extract<Extract<C, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends never ?
								(Extract<p, IterableOf<any>> extends IterableOf<infer q> ? (Exclude<p, IterableOf<any>> extends never ? never : Exclude<p, IterableOf<any>>) : never) |
								(Extract<p, IterableOf<any>> extends IterableOf<infer r> ? (Exclude<p, IterableOf<any>> extends never ? never : Extract<p, IterableOf<any>> extends never ? never :
									(Extract<Extract<p, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer s> ? (Exclude<Extract<p, IterableOf<any>>, IterableOf<any>> extends never ? never : Exclude<Extract<p, IterableOf<any>>, IterableOf<any>>) : never)) : never) : Exclude<Extract<Extract<C, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> |
								(Extract<Extract<Extract<C, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer t> ? (Exclude<Extract<Extract<C, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends never ? never : Extract<Extract<Extract<C, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends never ? never :
									(Extract<Extract<Extract<Extract<C, IterableOf<any>>, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer u> ? (Exclude<Extract<Extract<Extract<C, IterableOf<any>>, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends never ? never : Exclude<Extract<Extract<Extract<C, IterableOf<any>>, IterableOf<any>>, IterableOf<any>>, IterableOf<any>>) : never)) : never)) : never)) : never)) : never)) : never) : Exclude<B, IterableOf<any>> |
				(Extract<B, IterableOf<any>> extends IterableOf<infer v> ? (Exclude<B, IterableOf<any>> extends never ? never : Extract<B, IterableOf<any>> extends never ? never :
					(Extract<Extract<B, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer w> ? (Exclude<Extract<B, IterableOf<any>>, IterableOf<any>> extends never ?
						(Extract<w, IterableOf<any>> extends IterableOf<infer x> ? (Exclude<w, IterableOf<any>> extends never ?
							(Extract<x, IterableOf<any>> extends IterableOf<infer y> ? (Exclude<x, IterableOf<any>> extends never ? never : Exclude<x, IterableOf<any>>) : never) |
							(Extract<x, IterableOf<any>> extends IterableOf<infer z> ? (Exclude<x, IterableOf<any>> extends never ? never : Extract<x, IterableOf<any>> extends never ? never :
								(Extract<Extract<x, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer BA> ? (Exclude<Extract<x, IterableOf<any>>, IterableOf<any>> extends never ? never : Exclude<Extract<x, IterableOf<any>>, IterableOf<any>>) : never)) : never) : Exclude<w, IterableOf<any>> |
							(Extract<w, IterableOf<any>> extends IterableOf<infer BB> ? (Exclude<w, IterableOf<any>> extends never ? never : Extract<w, IterableOf<any>> extends never ? never :
								(Extract<Extract<w, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer BC> ? (Exclude<Extract<w, IterableOf<any>>, IterableOf<any>> extends never ? never : Exclude<Extract<w, IterableOf<any>>, IterableOf<any>>) : never)) : never)) : never) |
						(Extract<w, IterableOf<any>> extends IterableOf<infer BD> ? (Exclude<w, IterableOf<any>> extends never ? never : Extract<w, IterableOf<any>> extends never ? never :
							(Extract<Extract<w, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer BE> ? (Exclude<Extract<w, IterableOf<any>>, IterableOf<any>> extends never ?
								(Extract<BE, IterableOf<any>> extends IterableOf<infer BF> ? (Exclude<BE, IterableOf<any>> extends never ? never : Exclude<BE, IterableOf<any>>) : never) |
								(Extract<BE, IterableOf<any>> extends IterableOf<infer BG> ? (Exclude<BE, IterableOf<any>> extends never ? never : Extract<BE, IterableOf<any>> extends never ? never :
									(Extract<Extract<BE, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer BH> ? (Exclude<Extract<BE, IterableOf<any>>, IterableOf<any>> extends never ? never : Exclude<Extract<BE, IterableOf<any>>, IterableOf<any>>) : never)) : never) : Exclude<Extract<w, IterableOf<any>>, IterableOf<any>> |
								(Extract<Extract<w, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer BI> ? (Exclude<Extract<w, IterableOf<any>>, IterableOf<any>> extends never ? never : Extract<Extract<w, IterableOf<any>>, IterableOf<any>> extends never ? never :
									(Extract<Extract<Extract<w, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer BJ> ? (Exclude<Extract<Extract<w, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends never ? never : Exclude<Extract<Extract<w, IterableOf<any>>, IterableOf<any>>, IterableOf<any>>) : never)) : never)) : never)) : never) : Exclude<Extract<B, IterableOf<any>>, IterableOf<any>> |
						(Extract<Extract<B, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer BK> ? (Exclude<Extract<B, IterableOf<any>>, IterableOf<any>> extends never ? never : Extract<Extract<B, IterableOf<any>>, IterableOf<any>> extends never ? never :
							(Extract<Extract<Extract<B, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer BL> ? (Exclude<Extract<Extract<B, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends never ?
								(Extract<BL, IterableOf<any>> extends IterableOf<infer BM> ? (Exclude<BL, IterableOf<any>> extends never ? never : Exclude<BL, IterableOf<any>>) : never) |
								(Extract<BL, IterableOf<any>> extends IterableOf<infer BN> ? (Exclude<BL, IterableOf<any>> extends never ? never : Extract<BL, IterableOf<any>> extends never ? never :
									(Extract<Extract<BL, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer BO> ? (Exclude<Extract<BL, IterableOf<any>>, IterableOf<any>> extends never ? never : Exclude<Extract<BL, IterableOf<any>>, IterableOf<any>>) : never)) : never) : Exclude<Extract<Extract<B, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> |
								(Extract<Extract<Extract<B, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer BP> ? (Exclude<Extract<Extract<B, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends never ? never : Extract<Extract<Extract<B, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends never ? never :
									(Extract<Extract<Extract<Extract<B, IterableOf<any>>, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer BQ> ? (Exclude<Extract<Extract<Extract<B, IterableOf<any>>, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends never ? never : Exclude<Extract<Extract<Extract<B, IterableOf<any>>, IterableOf<any>>, IterableOf<any>>, IterableOf<any>>) : never)) : never)) : never)) : never)) : never)) : never)) : never) : Exclude<T, IterableOf<any>> |
			(Extract<T, IterableOf<any>> extends IterableOf<infer BR> ? (Exclude<T, IterableOf<any>> extends never ? never : Extract<T, IterableOf<any>> extends never ? never :
				(Extract<Extract<T, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer BS> ? (Exclude<Extract<T, IterableOf<any>>, IterableOf<any>> extends never ?
					(Extract<BS, IterableOf<any>> extends IterableOf<infer BT> ? (Exclude<BS, IterableOf<any>> extends never ?
						(Extract<BT, IterableOf<any>> extends IterableOf<infer BU> ? (Exclude<BT, IterableOf<any>> extends never ?
							(Extract<BU, IterableOf<any>> extends IterableOf<infer BV> ? (Exclude<BU, IterableOf<any>> extends never ? never : Exclude<BU, IterableOf<any>>) : never) |
							(Extract<BU, IterableOf<any>> extends IterableOf<infer BW> ? (Exclude<BU, IterableOf<any>> extends never ? never : Extract<BU, IterableOf<any>> extends never ? never :
								(Extract<Extract<BU, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer BX> ? (Exclude<Extract<BU, IterableOf<any>>, IterableOf<any>> extends never ? never : Exclude<Extract<BU, IterableOf<any>>, IterableOf<any>>) : never)) : never) : Exclude<BT, IterableOf<any>> |
							(Extract<BT, IterableOf<any>> extends IterableOf<infer BY> ? (Exclude<BT, IterableOf<any>> extends never ? never : Extract<BT, IterableOf<any>> extends never ? never :
								(Extract<Extract<BT, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer BZ> ? (Exclude<Extract<BT, IterableOf<any>>, IterableOf<any>> extends never ? never : Exclude<Extract<BT, IterableOf<any>>, IterableOf<any>>) : never)) : never)) : never) |
						(Extract<BT, IterableOf<any>> extends IterableOf<infer Ba> ? (Exclude<BT, IterableOf<any>> extends never ? never : Extract<BT, IterableOf<any>> extends never ? never :
							(Extract<Extract<BT, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer Bb> ? (Exclude<Extract<BT, IterableOf<any>>, IterableOf<any>> extends never ?
								(Extract<Bb, IterableOf<any>> extends IterableOf<infer Bc> ? (Exclude<Bb, IterableOf<any>> extends never ? never : Exclude<Bb, IterableOf<any>>) : never) |
								(Extract<Bb, IterableOf<any>> extends IterableOf<infer Bd> ? (Exclude<Bb, IterableOf<any>> extends never ? never : Extract<Bb, IterableOf<any>> extends never ? never :
									(Extract<Extract<Bb, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer Be> ? (Exclude<Extract<Bb, IterableOf<any>>, IterableOf<any>> extends never ? never : Exclude<Extract<Bb, IterableOf<any>>, IterableOf<any>>) : never)) : never) : Exclude<Extract<BT, IterableOf<any>>, IterableOf<any>> |
								(Extract<Extract<BT, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer Bf> ? (Exclude<Extract<BT, IterableOf<any>>, IterableOf<any>> extends never ? never : Extract<Extract<BT, IterableOf<any>>, IterableOf<any>> extends never ? never :
									(Extract<Extract<Extract<BT, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer Bg> ? (Exclude<Extract<Extract<BT, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends never ? never : Exclude<Extract<Extract<BT, IterableOf<any>>, IterableOf<any>>, IterableOf<any>>) : never)) : never)) : never)) : never) : Exclude<BS, IterableOf<any>> |
						(Extract<BS, IterableOf<any>> extends IterableOf<infer Bh> ? (Exclude<BS, IterableOf<any>> extends never ? never : Extract<BS, IterableOf<any>> extends never ? never :
							(Extract<Extract<BS, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer Bi> ? (Exclude<Extract<BS, IterableOf<any>>, IterableOf<any>> extends never ?
								(Extract<Bi, IterableOf<any>> extends IterableOf<infer Bj> ? (Exclude<Bi, IterableOf<any>> extends never ? never : Exclude<Bi, IterableOf<any>>) : never) |
								(Extract<Bi, IterableOf<any>> extends IterableOf<infer Bk> ? (Exclude<Bi, IterableOf<any>> extends never ? never : Extract<Bi, IterableOf<any>> extends never ? never :
									(Extract<Extract<Bi, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer Bl> ? (Exclude<Extract<Bi, IterableOf<any>>, IterableOf<any>> extends never ? never : Exclude<Extract<Bi, IterableOf<any>>, IterableOf<any>>) : never)) : never) : Exclude<Extract<BS, IterableOf<any>>, IterableOf<any>> |
								(Extract<Extract<BS, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer Bm> ? (Exclude<Extract<BS, IterableOf<any>>, IterableOf<any>> extends never ? never : Extract<Extract<BS, IterableOf<any>>, IterableOf<any>> extends never ? never :
									(Extract<Extract<Extract<BS, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer Bn> ? (Exclude<Extract<Extract<BS, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends never ? never : Exclude<Extract<Extract<BS, IterableOf<any>>, IterableOf<any>>, IterableOf<any>>) : never)) : never)) : never)) : never)) : never) |
					(Extract<BS, IterableOf<any>> extends IterableOf<infer Bo> ? (Exclude<BS, IterableOf<any>> extends never ? never : Extract<BS, IterableOf<any>> extends never ? never :
						(Extract<Extract<BS, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer Bp> ? (Exclude<Extract<BS, IterableOf<any>>, IterableOf<any>> extends never ?
							(Extract<Bp, IterableOf<any>> extends IterableOf<infer Bq> ? (Exclude<Bp, IterableOf<any>> extends never ?
								(Extract<Bq, IterableOf<any>> extends IterableOf<infer Br> ? (Exclude<Bq, IterableOf<any>> extends never ? never : Exclude<Bq, IterableOf<any>>) : never) |
								(Extract<Bq, IterableOf<any>> extends IterableOf<infer Bs> ? (Exclude<Bq, IterableOf<any>> extends never ? never : Extract<Bq, IterableOf<any>> extends never ? never :
									(Extract<Extract<Bq, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer Bt> ? (Exclude<Extract<Bq, IterableOf<any>>, IterableOf<any>> extends never ? never : Exclude<Extract<Bq, IterableOf<any>>, IterableOf<any>>) : never)) : never) : Exclude<Bp, IterableOf<any>> |
								(Extract<Bp, IterableOf<any>> extends IterableOf<infer Bu> ? (Exclude<Bp, IterableOf<any>> extends never ? never : Extract<Bp, IterableOf<any>> extends never ? never :
									(Extract<Extract<Bp, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer Bv> ? (Exclude<Extract<Bp, IterableOf<any>>, IterableOf<any>> extends never ? never : Exclude<Extract<Bp, IterableOf<any>>, IterableOf<any>>) : never)) : never)) : never) |
							(Extract<Bp, IterableOf<any>> extends IterableOf<infer Bw> ? (Exclude<Bp, IterableOf<any>> extends never ? never : Extract<Bp, IterableOf<any>> extends never ? never :
								(Extract<Extract<Bp, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer Bx> ? (Exclude<Extract<Bp, IterableOf<any>>, IterableOf<any>> extends never ?
									(Extract<Bx, IterableOf<any>> extends IterableOf<infer By> ? (Exclude<Bx, IterableOf<any>> extends never ? never : Exclude<Bx, IterableOf<any>>) : never) |
									(Extract<Bx, IterableOf<any>> extends IterableOf<infer Bz> ? (Exclude<Bx, IterableOf<any>> extends never ? never : Extract<Bx, IterableOf<any>> extends never ? never :
										(Extract<Extract<Bx, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer CA> ? (Exclude<Extract<Bx, IterableOf<any>>, IterableOf<any>> extends never ? never : Exclude<Extract<Bx, IterableOf<any>>, IterableOf<any>>) : never)) : never) : Exclude<Extract<Bp, IterableOf<any>>, IterableOf<any>> |
									(Extract<Extract<Bp, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer CB> ? (Exclude<Extract<Bp, IterableOf<any>>, IterableOf<any>> extends never ? never : Extract<Extract<Bp, IterableOf<any>>, IterableOf<any>> extends never ? never :
										(Extract<Extract<Extract<Bp, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer CC> ? (Exclude<Extract<Extract<Bp, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends never ? never : Exclude<Extract<Extract<Bp, IterableOf<any>>, IterableOf<any>>, IterableOf<any>>) : never)) : never)) : never)) : never) : Exclude<Extract<BS, IterableOf<any>>, IterableOf<any>> |
							(Extract<Extract<BS, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer CD> ? (Exclude<Extract<BS, IterableOf<any>>, IterableOf<any>> extends never ? never : Extract<Extract<BS, IterableOf<any>>, IterableOf<any>> extends never ? never :
								(Extract<Extract<Extract<BS, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer CE> ? (Exclude<Extract<Extract<BS, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends never ?
									(Extract<CE, IterableOf<any>> extends IterableOf<infer CF> ? (Exclude<CE, IterableOf<any>> extends never ? never : Exclude<CE, IterableOf<any>>) : never) |
									(Extract<CE, IterableOf<any>> extends IterableOf<infer CG> ? (Exclude<CE, IterableOf<any>> extends never ? never : Extract<CE, IterableOf<any>> extends never ? never :
										(Extract<Extract<CE, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer CH> ? (Exclude<Extract<CE, IterableOf<any>>, IterableOf<any>> extends never ? never : Exclude<Extract<CE, IterableOf<any>>, IterableOf<any>>) : never)) : never) : Exclude<Extract<Extract<BS, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> |
									(Extract<Extract<Extract<BS, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer CI> ? (Exclude<Extract<Extract<BS, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends never ? never : Extract<Extract<Extract<BS, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends never ? never :
										(Extract<Extract<Extract<Extract<BS, IterableOf<any>>, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer CJ> ? (Exclude<Extract<Extract<Extract<BS, IterableOf<any>>, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends never ? never : Exclude<Extract<Extract<Extract<BS, IterableOf<any>>, IterableOf<any>>, IterableOf<any>>, IterableOf<any>>) : never)) : never)) : never)) : never)) : never)) : never) : Exclude<Extract<T, IterableOf<any>>, IterableOf<any>> |
					(Extract<Extract<T, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer CK> ? (Exclude<Extract<T, IterableOf<any>>, IterableOf<any>> extends never ? never : Extract<Extract<T, IterableOf<any>>, IterableOf<any>> extends never ? never :
						(Extract<Extract<Extract<T, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer CL> ? (Exclude<Extract<Extract<T, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends never ?
							(Extract<CL, IterableOf<any>> extends IterableOf<infer CM> ? (Exclude<CL, IterableOf<any>> extends never ?
								(Extract<CM, IterableOf<any>> extends IterableOf<infer CN> ? (Exclude<CM, IterableOf<any>> extends never ? never : Exclude<CM, IterableOf<any>>) : never) |
								(Extract<CM, IterableOf<any>> extends IterableOf<infer CO> ? (Exclude<CM, IterableOf<any>> extends never ? never : Extract<CM, IterableOf<any>> extends never ? never :
									(Extract<Extract<CM, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer CP> ? (Exclude<Extract<CM, IterableOf<any>>, IterableOf<any>> extends never ? never : Exclude<Extract<CM, IterableOf<any>>, IterableOf<any>>) : never)) : never) : Exclude<CL, IterableOf<any>> |
								(Extract<CL, IterableOf<any>> extends IterableOf<infer CQ> ? (Exclude<CL, IterableOf<any>> extends never ? never : Extract<CL, IterableOf<any>> extends never ? never :
									(Extract<Extract<CL, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer CR> ? (Exclude<Extract<CL, IterableOf<any>>, IterableOf<any>> extends never ? never : Exclude<Extract<CL, IterableOf<any>>, IterableOf<any>>) : never)) : never)) : never) |
							(Extract<CL, IterableOf<any>> extends IterableOf<infer CS> ? (Exclude<CL, IterableOf<any>> extends never ? never : Extract<CL, IterableOf<any>> extends never ? never :
								(Extract<Extract<CL, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer CT> ? (Exclude<Extract<CL, IterableOf<any>>, IterableOf<any>> extends never ?
									(Extract<CT, IterableOf<any>> extends IterableOf<infer CU> ? (Exclude<CT, IterableOf<any>> extends never ? never : Exclude<CT, IterableOf<any>>) : never) |
									(Extract<CT, IterableOf<any>> extends IterableOf<infer CV> ? (Exclude<CT, IterableOf<any>> extends never ? never : Extract<CT, IterableOf<any>> extends never ? never :
										(Extract<Extract<CT, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer CW> ? (Exclude<Extract<CT, IterableOf<any>>, IterableOf<any>> extends never ? never : Exclude<Extract<CT, IterableOf<any>>, IterableOf<any>>) : never)) : never) : Exclude<Extract<CL, IterableOf<any>>, IterableOf<any>> |
									(Extract<Extract<CL, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer CX> ? (Exclude<Extract<CL, IterableOf<any>>, IterableOf<any>> extends never ? never : Extract<Extract<CL, IterableOf<any>>, IterableOf<any>> extends never ? never :
										(Extract<Extract<Extract<CL, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer CY> ? (Exclude<Extract<Extract<CL, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends never ? never : Exclude<Extract<Extract<CL, IterableOf<any>>, IterableOf<any>>, IterableOf<any>>) : never)) : never)) : never)) : never) : Exclude<Extract<Extract<T, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> |
							(Extract<Extract<Extract<T, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer CZ> ? (Exclude<Extract<Extract<T, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends never ? never : Extract<Extract<Extract<T, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends never ? never :
								(Extract<Extract<Extract<Extract<T, IterableOf<any>>, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer Ca> ? (Exclude<Extract<Extract<Extract<T, IterableOf<any>>, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends never ?
									(Extract<Ca, IterableOf<any>> extends IterableOf<infer Cb> ? (Exclude<Ca, IterableOf<any>> extends never ? never : Exclude<Ca, IterableOf<any>>) : never) |
									(Extract<Ca, IterableOf<any>> extends IterableOf<infer Cc> ? (Exclude<Ca, IterableOf<any>> extends never ? never : Extract<Ca, IterableOf<any>> extends never ? never :
										(Extract<Extract<Ca, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer Cd> ? (Exclude<Extract<Ca, IterableOf<any>>, IterableOf<any>> extends never ? never : Exclude<Extract<Ca, IterableOf<any>>, IterableOf<any>>) : never)) : never) : Exclude<Extract<Extract<Extract<T, IterableOf<any>>, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> |
									(Extract<Extract<Extract<Extract<T, IterableOf<any>>, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer Ce> ? (Exclude<Extract<Extract<Extract<T, IterableOf<any>>, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends never ? never : Extract<Extract<Extract<Extract<T, IterableOf<any>>, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends never ? never :
										(Extract<Extract<Extract<Extract<Extract<T, IterableOf<any>>, IterableOf<any>>, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends IterableOf<infer Cf> ? (Exclude<Extract<Extract<Extract<Extract<T, IterableOf<any>>, IterableOf<any>>, IterableOf<any>>, IterableOf<any>>, IterableOf<any>> extends never ? never : Exclude<Extract<Extract<Extract<Extract<T, IterableOf<any>>, IterableOf<any>>, IterableOf<any>>, IterableOf<any>>, IterableOf<any>>) : never)) : never)) : never)) : never)) : never)) : never)) : never)) : never)) : never> : IterableIterator<A>) : never;
		// tslint:enable max-line-length

		/**
		 * Returns an iterator returning only the values between `startIndex` and `endIndex`.
		 * @param startIndex Inclusive
		 * @param endIndex Exclusive, defaults to `Infinity` (entire iterator)
		 *
		 * Note: When passed negative indices, it works, but it's slower as it has to loop through
		 * the entire iterable first.
		 */
		slice (startIndex: number, endIndex?: number): IterableIterator<T>;

		/**
		 * Returns an iterator for the values of this iterator (it returns itself).
		 */
		values (): IterableIterator<T>;

		/**
		 * Returns an iterator for tuples containing the indices and the values of this iterator.
		 */
		entries (): IterableIterator<[number, T]>;

		awaitAll (): T extends Promise<infer X> ? AsyncIterableIterator<X> : never;

		at (index: number): T;
	}

	interface RegExp {
		/**
		 * Returns an iterator for the matches of this string.
		 */
		matches (string: string): IterableIterator<RegExpExecArray>;
	}

	interface Array<T> {

		/**
		 * Returns an iterator for the values of this array.
		 * This method will be removed when it becomes native in Chromium 66+
		 */
		values (): IterableIterator<T>;

		/**
		 * Returns an iterator for tuples containing the indices and the values of this array.
		 */
		entries (): IterableIterator<[number, T]>;

		/**
		 * Returns the first element in the array.
		 *
		 * Make a TS issue if you want to remove this helper. `[0]` doesn't want to stay indented.
		 */
		first (): T;

		/**
		 * Returns the last element in the array.
		 *
		 * Make a TS issue if you want to remove this helper. Same thing as `.first()` but also this
		 * is nicer than `[this.length - 1]`
		 */
		last (): T;

		toggle (value: T, includes?: boolean): number;
	}

	interface AsyncIterableIterator<T> {
		/**
		 * Returns a value of type X, generated with the given collector function.
		 * @param collector A function that takes the iterable, and returns type X
		 * @see `utilities/Collectors` for premade collectors
		 */
		collect<X> (collector: (val: AsyncIterableIterator<T>) => Promise<X>): Promise<X>;
		/**
		 * Returns an iterable of type X, generated with the given collector function.
		 * @param collector A function that takes the iterable, and returns type X
		 * @see `utilities/Collectors` for premade collectors
		 */
		collect<X> (collector: (val: AsyncIterableIterator<T>) => Promise<X>, iterable: true): AsyncIterableIterator<X>;
	}

	interface Map<K, V> {
		/**
		 * Sets multiple entries in this map from an iterable of entries
		 */
		setAll<I extends IterableOf<[K, V]> | AsyncIterableIterator<[K, V]>> (entriesIterable: I): I extends IterableOf<[K, V]> ? void : Promise<void>;
	}

	interface MapConstructor {
		/**
		 * Creates a map from an iterable of entries
		 */
		create<K, V> (entriesIterable: IterableOf<[K, V]>): Map<K, V>;
		/**
		 * Creates a map from an async iterable of entries
		 */
		createAsync<K, V> (entriesIterable: AsyncIterableIterator<[K, V]>): Promise<Map<K, V>>;
	}

	interface Function {
		// tslint:disable-next-line ban-types ...lol
		callNative: Function["call"];
		// tslint:disable-next-line ban-types
		applyNative: Function["apply"];
		// tslint:disable-next-line ban-types
		bindNative: Function["bind"];
	}

	////////////////////////////////////
	// Misc changes to other modules
	//

	interface PromiseConstructor {
		allUnbound: PromiseConstructor["all"];
	}
}

///////////////////////////////////
// New iterator methods
//

/**
 * One quirk with the `Iterator` support is that ones created from generator functions, `ArrayIterator`s,
 * and `MapIterator`s are all different. We want this support to be available on each, so we make a list
 * of everything that is an `IterableIterator` and then add all our methods to each in a loop.
 */
const prototypes = [
	Object.getPrototypeOf(function* (): any { }).prototype,
	Object.getPrototypeOf([][Symbol.iterator]()),
	Object.getPrototypeOf(new Map().keys()),
];

const iteratorImpl = {
	values (this: IterableIterator<any>) {
		return this;
	},

	*entries (this: IterableIterator<any>) {
		let i = 0;
		for (const val of this) {
			yield [i++, val];
		}
	},

	*map (this: IterableIterator<any>, mapper: (val: any, index: number) => any) {
		let index = 0;
		for (const val of this) {
			yield mapper(val, index++);
		}
	},

	*filter (this: IterableIterator<any>, filter: (val: any) => boolean) {
		for (const val of this) {
			if (filter(val)) {
				yield val;
			}
		}
	},

	*filter2 (this: IterableIterator<any>, filter: (val: any) => boolean) {
		for (const val of this) {
			if (filter(val)) {
				yield val;
			}
		}
	},

	*include (this: IterableIterator<any>, ...iterables: Array<IterableOf<any>>) {
		for (const val of this) {
			yield val;
		}

		for (const iterable of iterables) {
			for (const val of iterable) {
				yield val;
			}
		}
	},

	*flat (this: IterableIterator<any>, levels = Infinity) {
		for (const val of this) {
			if (levels > 0 && isIterable(val)) {
				for (const val2 of val[Symbol.iterator]().flat(levels - 1)) {
					yield val2;
				}

			} else {
				yield val;
			}
		}
	},

	*slice (this: IterableIterator<any>, startIndex: number, endIndex = Infinity) {
		let arr: IterableOf<any> = this;

		if (Math.min(startIndex, endIndex) < 0) {
			arr = this.collect(Collectors.toArray);

			if (startIndex < 0) {
				startIndex = arr.length + startIndex;
			}

			if (endIndex < 0) {
				endIndex = arr.length + endIndex;
			}
		}

		if (endIndex <= startIndex) {
			return undefined;
		}

		let i = 0;
		for (const val of arr) {
			if (i >= startIndex) {
				yield val;
			}

			i++;

			if (i >= endIndex) {
				break;
			}
		}
	},

	reduce (this: IterableIterator<any>, reducer: (oldValue: any | undefined, entry: any) => any, defaultValue?: any) {
		let result = defaultValue;

		for (const val of this) {
			result = reducer(val, result);
		}

		return result;
	},

	any (this: IterableIterator<any>, predicate: (val: any, index: number) => boolean) {
		let index = 0;
		for (const val of this) {
			if (predicate(val, index++)) {
				return true;
			}
		}

		return false;
	},

	nevery (this: IterableIterator<any>, predicate: (val: any, index: number) => boolean) {
		let index = 0;
		for (const val of this) {
			if (!predicate(val, index++)) {
				return true;
			}
		}

		return false;
	},

	every (this: IterableIterator<any>, predicate: (val: any, index: number) => boolean) {
		let index = 0;
		for (const val of this) {
			if (!predicate(val, index++)) {
				return false;
			}
		}

		return true;
	},

	none (this: IterableIterator<any>, predicate: (val: any, index: number) => boolean) {
		let index = 0;
		for (const val of this) {
			if (predicate(val, index++)) {
				return false;
			}
		}

		return true;
	},

	anyMatch (this: IterableIterator<any>, predicate: (value: any) => boolean) {
		for (const val of this) {
			if (predicate(val)) {
				return true;
			}
		}

		return false;
	},

	allMatch (this: IterableIterator<any>, predicate: (value: any) => boolean) {
	},

	collect (collector: (val: any) => any, iterable = false) {
		if (iterable) {
			const originalGenerator = this;
			return (function* () {
				yield collector(originalGenerator);
			})();
		}

		return collector(this);
	},

	first (this: IterableIterator<any>, orElseOrUserFunction?: any) {
		if (typeof orElseOrUserFunction === "function") {
			orElseOrUserFunction(this.first());
		}

		for (const value of this) {
			return value;
		}

		return orElseOrUserFunction;
	},

	last (this: IterableIterator<any>, orElseOrUserFunction?: any) {
		if (typeof orElseOrUserFunction === "function") {
			orElseOrUserFunction(this.first());
		}

		let result = orElseOrUserFunction;

		for (const value of this) {
			result = value;
		}

		return result;
	},

	random (this: IterableIterator<any>, orElse?: any) {
		const all = this.collect(Collectors.toArray);
		return all[Math.floor(Math.random() * all.length)];
	},

	forEach (this: IterableIterator<any>, user: (val: any, index: number) => boolean | undefined, continueGeneration: boolean) {
		if (continueGeneration) {
			return (this as any).forEachContinue(user);
		}

		let index = 0;
		for (const value of this) {
			if (user(value, index++) === false) {
				return;
			}
		}
	},

	*forEachContinue (this: IterableIterator<any>, user: (val: any) => boolean | undefined) {
		for (const value of this) {
			yield value;

			if (user(value) === false) {
				return undefined;
			}
		}
	},

	async *awaitAll (this: IterableIterator<Promise<any>>) {
		for (const value of this) {
			yield await value;
		}
	},

	at (this: IterableIterator<any>, index: number) {
		let i = 0;
		for (const value of this) {
			if (i++ == index) {
				return value;
			}
		}

		return undefined;
	},

	split (this: IterableIterator<any>, splitter: (val: any) => string) {
		const originalGenerator = this;

		const iterableMap: IterableMap = {};

		function getIterable (key: string) {
			if (!(key in iterableMap)) {
				iterableMap[key] = {
					preiterated: [],
					iterator: (function* (): any {
						const preiterated = iterableMap[key].preiterated;
						while (true) {
							if (preiterated.length > 0) {
								yield preiterated.shift();

							} else {
								const result = originalGenerator.next();
								if (result.done) {
									break;
								}

								const splitTo = splitter(result.value);
								if (splitTo === key) {
									yield result.value;

								} else {
									const iterable = getIterable(splitTo);
									iterable.preiterated.push(result.value);
								}
							}
						}
					})(),
				};
			}

			return iterableMap[key];
		}

		const proxy = new Proxy({}, {
			get: (_, key: string) => getIterable(key).iterator,
		});

		(proxy as any)[IterableIterator.ALL] = getIterable(IterableIterator.ALL as any).iterator;

		return proxy;
	},
};

for (const prototype of prototypes) {
	for (const method in iteratorImpl) {
		prototype[method] = iteratorImpl[method as keyof typeof iteratorImpl];
	}
}

interface IterableMap {
	[key: string]: {
		preiterated: any[];
		iterator: IterableIterator<any>;
	};
}

const asyncIterableIteratorPrototype = Object.getPrototypeOf(async function* (): any { }).prototype;

const asyncIterableIteratorImpl = {
	async collect (collector: (val: any) => Promise<any>, iterable = false) {
		if (iterable) {
			const originalGenerator = this;
			return (async function* () {
				yield await collector(originalGenerator);
			})();
		}

		return collector(this);
	},
};

for (const method in asyncIterableIteratorImpl) {
	asyncIterableIteratorPrototype[method] = asyncIterableIteratorImpl[method as keyof typeof asyncIterableIteratorImpl];
}

///////////////////////////////////
// New array methods
//

Object.defineProperty(Array.prototype, "values", {
	value (this: any[]) {
		return this[Symbol.iterator]();
	},
});

Object.defineProperty(Array.prototype, "entries", {
	*value (this: any[]) {
		for (let i = 0; i < this.length; i++) {
			yield [i, this[i]];
		}
	},
});

Object.defineProperty(Array.prototype, "first", {
	value (this: any[]) {
		return this[0];
	},
});

Object.defineProperty(Array.prototype, "last", {
	value (this: any[]) {
		return this[this.length - 1];
	},
});

Object.defineProperty(Array.prototype, "toggle", {
	value (this: any[], value: any, includes?: boolean) {
		const index = this.indexOf(value);
		// figure out what we're toggling it to
		if (includes === undefined) {
			includes = index === -1;
		}

		// add it
		if (includes) {
			if (index >= 0) {
				return index;
			}

			return this.push(value);
		}

		// remove it
		this.splice(index, 1);
		return -1;
	},
});

///////////////////////////////////
// New Map methods
//

Object.defineProperty(Map.prototype, "setAll", {
	value (this: Map<any, any>, toSet: IterableOf<[any, any]> | AsyncIterableIterator<[any, any]>) {
		if (Object.getPrototypeOf(toSet).__proto__[Symbol.toStringTag] === "AsyncGenerator") {
			return (async () => {
				for await (const [key, value] of toSet as AsyncIterableIterator<[any, any]>) {
					this.set(key, value);
				}
			})();

		} else {
			for (const [key, value] of toSet as IterableOf<[any, any]>) {
				this.set(key, value);
			}
		}

		return undefined;
	},
});

Map.create = function (entriesIterable: IterableOf<[any, any]>) {
	const result = new Map();
	result.setAll(entriesIterable);
	return result;
};

Map.createAsync = function (entriesIterable: AsyncIterableIterator<[any, any]>) {
	return new Promise<Map<any, any>>(async resolve => {
		const result = new Map();
		await result.setAll(entriesIterable);
		resolve(result);
	}) as any;
};

///////////////////////////////////
// Function methods
//

function isClass (v: any) {
	return typeof v === "function" && /^\s*class\s+/.test(v.toString());
}

/*
 * For some reason, class constructors don't work with `bind`, `apply`, and `call`, while prototypal
 * constructors work just fine. To allow this functionality, we replace the native versions with
 * our own. These functions are already fairly slow (compared to normal calls) and shouldn't be
 * called frequently. With that in mind, we can safely replace the native versions without worrying
 * about performance.
 */

Object.defineProperty(Function.prototype, "bindNative", { value: Function.prototype.bind });
Object.defineProperty(Function.prototype, "applyNative", { value: Function.prototype.apply });
Object.defineProperty(Function.prototype, "callNative", { value: Function.prototype.call });

Object.defineProperty(Function.prototype, "bind", {
	value (this: any, scope: any, ...preProvidedArgs: any[]) {
		return isClass(this) ? (...args: any[]) => new this(...preProvidedArgs, ...args) : this.bindNative(scope, ...preProvidedArgs);
	},
});

Object.defineProperty(Function.prototype, "apply", {
	value (this: any, scope: any, args: any[]) {
		return isClass(this) ? new this(...args) : this.applyNative(scope, args);
	},
});

Object.defineProperty(Function.prototype, "call", {
	value (this: any, scope: any, ...args: any[]) {
		return isClass(this) ? new this(...args) : this.callNative(scope, ...args);
	},
});

///////////////////////////////////
// RegExp methods
//

Object.defineProperty(RegExp.prototype, "matches", {
	*value (this: RegExp, str: string) {
		while (true) {
			const arr = this.exec(str);
			if (arr) {
				yield arr;

			} else {
				break;
			}
		}
	},
});

////////////////////////////////////
// Misc changes to other modules
//

Promise.allUnbound = Promise.all;
Promise.all = Promise.all.bind(Promise);

/**
 * This is an empty function. The `IterableIterator` support is applied globally when this
 * module is imported--however, this module will be removed by Uglify because Uglify is
 * dumb, unless we provide something to use when importing this module. As a result, it's
 * only useful to import this module once. Currently, it is done in the module `Game`.
 */
function IterableIterator () { }

module IterableIterator {
	export const ALL = Symbol("all");
}

export default IterableIterator;

export function pipe<T extends any[]> (...what: T): IterableIterator<T[number]> {
	return what.values();
}

type ExtractPromiseValue<P extends Promise<any>> = P extends Promise<infer V> ? V : never;

export async function* pipeAsync<T extends Promise<any>[]> (...what: T): AsyncIterableIterator<ExtractPromiseValue<T[number]>> {
	for (const item of what) {
		yield await item;
	}
}

/**
 * A generator for numbers from `0` through `end` (exclusive)
 */
export function range (end: number): IterableIterator<number>;
/**
 * A generator for numbers from `start` (inclusive) through `end` (exclusive)
 */
export function range (start: number, end: number): IterableIterator<number>;
export function* range (start: number, end?: number) {
	if (end === undefined) {
		end = start;
		start = 0;
	}

	for (let i = start; i < end; i++) {
		yield i;
	}
}

export function isIterable (obj: any): obj is IterableOf<any> {
	return obj && typeof obj === "object" && Symbol.iterator in obj;
}

export function pushTo<T> (arr: T[]) {
	return (...wat: any[]) => {
		arr.push(...wat);
		return wat[0];
	};
}

export function construct<R, F extends new () => R> (f: F): () => R;
export function construct<_A, R, F extends new (_1: _A) => R> (f: F): (_1: _A) => R;
export function construct<_A, _B, R, F extends new (_1: _A, _2: _B) => R> (f: F): (_1: _A, _2: _B) => R;
export function construct<_A, _B, _C, R, F extends new (_1: _A, _2: _B, _3: _C) => R> (f: F): (_1: _A, _2: _B, _3: _C) => R;
export function construct<_A, _B, _C, _D, R, F extends new (_1: _A, _2: _B, _3: _C, _4: _D) => R> (f: F): (_1: _A, _2: _B, _3: _C, _4: _D) => R;
export function construct<_A, _B, _C, _D, _E, R, F extends new (_1: _A, _2: _B, _3: _C, _4: _D, _5: _E) => R> (f: F): (_1: _A, _2: _B, _3: _C, _4: _D, _5: _E) => R;
export function construct<R, F extends new (...args: any[]) => R> (f: F): (...args: any[]) => R {
	return f.bind(null);
}

export function tuple<T extends any[]> (...items: T): T {
	return items;
}
